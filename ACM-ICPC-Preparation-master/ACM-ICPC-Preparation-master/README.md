![ACM-ICPC](https://github.com/NAU-ACM/ACM-ICPC-Preparation/blob/master/acm_icpc_prep.jpg "ACM-ICPC")

# ACM-ICPC Preparation 
![](https://img.shields.io/badge/NAU-in%20progress-blue.svg) ![](https://img.shields.io/badge/licence-MIT-green.svg) ![](https://img.shields.io/badge/Weeks%20Completed-8%2F20-orange.svg)

This program has been developed to learn Algorithms for use in Competitive Prorgamming, **but can be used for:**
  - Competitive Programming
  - Practicing for Interviews
  - Improving Algorithmic Thinking
  - Practicing for College Classes
  - FUN

**The course requires:** 
  - To know at least one programming language well. (_You have to be able to use the language efficiently._)
  - You have to be familiar with some of the basic Data Structures (Array, Stack, Queue, etc.) (_Although if you don't know one of them, you may learn it when you come across it._)

###### _PS: I am saying "Any programming language" but in this course mostly we used C, C++ and some Java, but you can still follow the curriculum without any knowledge of these languages_

In the program there is only direction to resources, we did not add much content apart from what already existed. We just collected good sources to learn in one place, so that one can follow up and learn. The course includes algorithms and a bit data structures. You need to follow the the curriculum week by week.

**Basic following guide would be to:**
  1. See the sources to study
  2. Get the logic and try to code it without looking other code
  3. When you are stuck(you really should try first) or when you are done, look at the source code, and compare it with yours so that you can see what would be the best approach for that algorithm. You may not like others, or you may find some of them useful.
  4. After you feel comforatable with the code, try to solve the questions.
  5. When you are done with solving or are stuck(again ...) check other solutions and try to understand your mistake or to see if a better aproach exists.

## Resources

In this course we will use some tools for the questions. As I mentioned above all of these questions already exist, we just highlight them so that you can reach them easier. Here are the websites/tools that we use through this course:

  - [Leetcode](https://leetcode.com)
  - [Spoj](http://www.spoj.com)
  - [Hackerrank](https://www.hackerrank.com/domains)
  - [Topcoder](https://www.topcoder.com)
  - [Codeforces](http://codeforces.com)
  - [Lightoj](http://www.lightoj.com)
  - [ACM-Timus](http://acm.timus.ru)

I gave these tools name because you may not be able to submit your solution or display the question for some websites. It would be better if you just sign up. Although it is not neccesary...

## Contribution

We are open to any support. If you have anything to add, do not hesitate to offer! For further information you can check [Code of Conduct](CODE_OF_CONDUCT.md)

## Topics

Here are the topics we included in this curriculum.

### DS

  - Stacks
  - Queues
  - Priority queue
  - Hashmap
  - Linked List
  - Trees
  - Heaps
  - Advanced Trees 
    - Tries
    - Segment trees
    - Fenwick tree or Binary indexed trees
    - RMQ
  - SQRT Decomposition
  - Disjoint Data Structure
  - C++ STL (optional)

### Algo

  - Number Theory 
    - Prime Numbers (Sieve of Eratosthenes)
    - GCD and LCM Euclid’s Algorithm
    - Modular Exponentiation
    - Long arithmetic (Multi, Add)
    - Efficient Prime Factorization

  - Combinatorics(Probability-Combinations-Permutations-Matrix..)

  - Computational geometry
    - Primitive Operations
      - Intuition
      - Polygon Inside, Outside
      - Implementing CCW
      - Immutable Point ADT
    - Convex Hull
    - Closest pair problem
    - Line intersection

  - Sorting
    - QuickSort
    - Counting Sort
    - Merge Sort

  - Searching
    - Binary Search
    - Ternary Search

  - Graph Theory
    - Depth First Search (DFS)
    - Breadth First Search (BFS)
    - Dijkstra’s Shortest Path
    - Minimum Spanning Tree 
    - Ford Bellman
    - Floyd Warshall
    - LCA (Lowest Common Ancestor)
    - Max Flow / Min Cut

  - Dynamic programming
    - Knapsack
    - Matrix chain multiplication
    - Coin Change
    - Kadane
    - Longest increasing Subsequence (with RMQ)

  - Strings
    - Z algorithm
    - Suffix Trees/Arrays
    - Knuth-Morris-Pratt Algorithm (KMP)
    - Rabin-Karp Algorithm
    - Hash

  - Bit Manipulation

  - Game theory
    - Nim game
    - Grundy numbers
    - Sprague-Grundy theorem

  - **Optional Advanced Algorithms**
    - AVL Trees
    - Graph Coloring
    - Mo's Algorithm
    - Palindromic Tree
    - Heavy Light Decomposition
    - Dynamic Programming by Profile
    - Rod Cutting
    - Topological Sorting
    - DP with Bitmask - Dynamic Programming
    - Diobhantine Equation - Math
    - Flood Fill - Graph


## Here is our Curriculum
|Week|Topics|Optional Topics|
| --- | --- | --- |
|[**Heads Up **](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week00)|<ul><li>Big O Notation</li></ul>||
|[**1.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week01)|<ul><li>Prime Numbers (Sieve of Eratosthenes)</li><li>Efficient Prime Factorization</li><li>Modular Exponentiation</li></ul>||
|[**2.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week02)|<ul><li>GCD and LCM Euclid’s Algorithm</li><li>Long arithmetic (Multi, Sum, Div, Sub)</li></ul>|<ul><li>C++ STL:Vector</li><li>C++ STL:Pairs</li><li>C++ STL:Iterators</li></ul>|
|[**3.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week03)|<ul><li>QuickSort</li><li>Counting Sort</li></ul>|<ul><li>C++ STL:String</li><li>C++ STL:Set</li><li>C++ STL:Map</li></ul>|
|[**4.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week04)|<ul><li>Merge Sort</li><li>Binary Search</li></ul>|<ul><li>Ternary Search</li></ul>|
|[**5.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week05)|<ul><li>Queue (DS)</li><li>Stack (DS)</li><li>Breadth First Search</li><li>Depth First Search</li></ul>|<ul><li>C++ STL: Queue</li><li>C++ STL: Stack</li></ul>|
|[**6.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week06)|<ul><li>Linked List (DS)</li><li>Dijkstra’s Shortest Path</li><li>Minimum Spanning Tree (MST)</li><li>Floyd Warshall</li></ul>|<ul><li>Cycle Detection (Union Find)</li></ul>|
|[**7.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week07)|<ul><li>Knapsack</li><li>Coin Change</li><li>Kadane</li></ul>||
|[**8.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week08)|**Questions from previous topics**||
|[**9.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week09)|<ul><li>Trees (DS)</li><li>Segment Trees (DS)</li><li>Range Minimum Query (RMQ)</li><li>Lowest Common Ancestor (LCA)</li></ul>|<ul><li>Topological Sorting</li></ul>|
|[**10.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week10)|<ul><li>Ford Bellman</li><li>Max Flow / Min Cut</li><li>Longest increasing Subsequence (with RMQ)</li></ul>|<ul><li>Heavy Light Decomposition</li></ul>|
|[**11.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week11)|<ul><li>Primitive Operations<ul><li>Intuition</li><li>Polygon Inside, Outside</li><li>Implementing CCW</li><li>Immutable Point ADT</li></ul></li><li>Convex Hull</li><li>Closest pair problem</li><li>Line intersection</li></ul>||
|[**12.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week12)|<ul><li>Tries (DS)</li><li>Suffix Trees/Arrays (DS)</li><li>Knuth-Morris-Pratt Algorithm (KMP)</li><li>Rabin-Karp Algorithm</li></ul>||
|[**13.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week13)|<ul><li>Heaps (DS)</li><li>Priority queue (DS)</li><li>Combinatorics</li></ul>||
|[**14.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week14)|<ul><li>Z algorithm</li><li>Hash</li><li>Disjoint Data Structure (DS)</li></ul>||
|[**15.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week15)|<ul><li>Matrix chain multiplication</li><li>SQRT Decomposition (DS)</li></ul>|<ul><li>Mo's Algorithm</li><li>Rod Cutting</li></ul>|
|[**16.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week16)|**Questions from previous topics**||
|[**17.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week17)|<ul><li>Nim game</li><li>Grundy numbers</li></ul>||
|[**18.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week18)|<ul><li>Sprague-Grundy theorem</li><li>Fenwick tree or Binary indexed trees (DS)</li></ul>||
|[**19.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week19)|<ul><li>Bit Manipulation</li></ul>|<ul><li>Palindromic Tree</li><li>AVL Trees</li></ul>|
|[**20.Week**](https://github.com/NAU-ACM/ACM-ICPC-Preparation/tree/master/Week20)|<ul><li>Heavy Light Decomposition</li><li>Dynamic Programming by Profile</li></ul>|<ul><li>Graph Coloring</li></ul>|


### [Contributers](https://github.com/NAU-ACM/ACM-ICPC-Preparation/graphs/contributors)

###### A [NAU-ACM](https://nauacmrocks.azurewebsites.net) Project

